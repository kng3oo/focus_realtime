<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <title>Focus Realtime Dashboard</title>
  <style>
    body{font-family:Arial,system-ui;background:#020617;color:#e5e7eb;margin:0;padding:16px}
    h1{margin-top:0;margin-bottom:12px}
    .row{display:flex;flex-wrap:wrap;gap:12px}
    .card{background:#020617;border-radius:10px;padding:12px;border:1px solid #1e293b;box-shadow:0 4px 10px rgba(0,0,0,0.4);flex:1;min-width:280px}
    #cam{max-width:640px;width:100%;border-radius:8px;background:#000}
    label{font-size:0.9rem;color:#9ca3af}
    input[type="text"]{padding:4px 8px;border-radius:6px;border:1px solid #4b5563;background:#020617;color:#e5e7eb}
    button{padding:6px 12px;border:none;border-radius:6px;margin-right:6px;cursor:pointer;font-weight:600}
    .btn-start{background:#22c55e;color:#022c22}
    .btn-stop{background:#ef4444;color:#fee2e2}
    .btn-snap{background:#3b82f6;color:#dbeafe}
    .metric{margin:4px 0}
    .metric span.label{color:#9ca3af;margin-right:4px}
    .metric span.value{font-weight:600}
    pre{background:#020617;border-radius:8px;padding:8px;border:1px solid #1e293b;overflow:auto}
    ul{padding-left:18px;margin:4px 0}
    li{font-size:0.85rem}
  </style>
</head>
<body>
  <h1>Focus Realtime Dashboard</h1>

  <div class="card" style="margin-bottom:12px;">
    <div style="display:flex;flex-wrap:wrap;align-items:center;gap:8px;">
      <div>
        <label for="username">사용자 이름</label><br/>
        <input id="username" type="text" placeholder="예: 홍길동"/>
      </div>
      <div>
        <button class="btn-start" onclick="onStart()">시작</button>
        <button class="btn-stop" onclick="onStop()">중지</button>
        <button class="btn-snap" onclick="onSnapshot()">현재 이미지 저장</button>
      </div>
      <div style="font-size:0.85rem;color:#9ca3af;">
        ※ 이름 입력 후 <b>시작</b>을 눌러야 스트리밍이 시작됩니다.
      </div>
    </div>
  </div>

  <div class="row">
    <div class="card">
      <h3>Live Camera (Local)</h3>
      <video id="cam" autoplay playsinline></video>
      <p style="font-size:0.85rem;color:#9ca3af;margin-top:6px;">
        이 영상은 <b>로컬 PC</b>에서만 보이며, 서버에는 프레임 이미지 데이터만 전송됩니다.
      </p>
      <p style="font-size:0.8rem;color:#6b7280;">
        로그는 서버에서 CSV로 자동 저장되고, 집중도 40% 미만일 때 캡처 이미지가 자동 저장됩니다.
      </p>
    </div>

    <div class="card">
      <h3>집중도 & 평균</h3>
      <div class="metric"><span class="label">현재 집중도:</span> <span id="focusNow" class="value">0%</span></div>
      <div class="metric"><span class="label">10초 평균:</span> <span id="avg10" class="value">0%</span></div>
      <div class="metric"><span class="label">1분 평균:</span> <span id="avg60" class="value">0%</span></div>
      <div class="metric"><span class="label">10분 평균:</span> <span id="avg600" class="value">0%</span></div>

      <div class="metric"><span class="label">FPS:</span> <span id="fps" class="value">0</span></div>
      <div class="metric"><span class="label">Frames:</span> <span id="frames" class="value">0</span></div>
      <div class="metric"><span class="label">Saved Images:</span> <span id="saved" class="value">0</span></div>

      <div style="margin-top:8px;font-size:0.85rem;color:#9ca3af;">
        집중도는 Emotion(70%) + Blink(30%) 가중합으로 계산되며,<br/>
        40% 미만 시 자동으로 스크린샷이 저장됩니다.
      </div>
    </div>

    <div class="card">
      <h3>감정 빈도수 랭킹 (세션 기준)</h3>
      <ul id="emotionRank"></ul>

      <h3 style="margin-top:10px;">Latest Detail</h3>
      <pre id="latest" style="font-size:0.8rem;max-height:200px;">loading...</pre>
    </div>
  </div>

  <script>
    let userName = "";
    let stream = null;
    let captureTimer = null;
    let pollTimer = null;
    const focusHist = [];
    const emotionCount = {};  // 감정 빈도수 집계

    async function startCameraIfNeeded() {
      if (stream) return;
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video: true });
        const video = document.getElementById("cam");
        video.srcObject = stream;
      } catch (e) {
        alert("카메라 접근 실패: " + e);
      }
    }

    function stopCameraCapture() {
      if (captureTimer) {
        clearInterval(captureTimer);
        captureTimer = null;
      }
    }

    function avgPercent(arr, count) {
      if (arr.length === 0) return 0;
      const slice = arr.slice(-count);
      if (slice.length === 0) return 0;
      const s = slice.reduce((a,b)=>a+b,0)/slice.length;
      return Math.round(s * 100);
    }

    async function sendFrame() {
      const video = document.getElementById("cam");
      if (!video.videoWidth || !video.videoHeight) return;
      if (!userName) return;

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = 320;
      canvas.height = 240;
      ctx.drawImage(video, 0, 0, 320, 240);
      const blob = await new Promise(res => canvas.toBlob(res, "image/jpeg", 0.7));
      const fd = new FormData();
      fd.append("frame", blob, "frame.jpg");
      fd.append("user", userName);

      fetch("/api/frame", { method:"POST", body: fd }).catch(()=>{});
    }

    async function poll() {
      try {
        const liveRes = await fetch("/api/live");
        const live = await liveRes.json();
        const sessRes = await fetch("/api/session");
        const sess = await sessRes.json();

        const focusArr = live.focus || [];
        const fps = live.fps || 0;
        const latest = live.latest || {};

        if (focusArr.length > 0) {
          const last = focusArr[focusArr.length - 1];
          focusHist.push(last);
          document.getElementById("focusNow").innerText = Math.round(last*100) + "%";
        }

        const fpsSafe = Math.max(5, fps || 10);
        const n10 = Math.round(fpsSafe * 10);
        const n60 = Math.round(fpsSafe * 60);
        const n600 = Math.round(fpsSafe * 600);

        document.getElementById("avg10").innerText = avgPercent(focusHist, n10) + "%";
        document.getElementById("avg60").innerText = avgPercent(focusHist, n60) + "%";
        document.getElementById("avg600").innerText = avgPercent(focusHist, n600) + "%";

        document.getElementById("fps").innerText = fps.toFixed ? fps.toFixed(1) : fps;
        document.getElementById("frames").innerText = sess.frames || 0;
        document.getElementById("saved").innerText = sess.saved || 0;

        // latest 정보 표시 (모든 수치 %화)
        const latestCopy = { ...latest };
        if (latestCopy.focus != null) latestCopy.focus = (latestCopy.focus*100).toFixed(1) + "%";
        if (latestCopy.emotion_score != null) latestCopy.emotion_score = (latestCopy.emotion_score*100).toFixed(1) + "%";
        if (latestCopy.blink_score != null) latestCopy.blink_score = (latestCopy.blink_score*100).toFixed(1) + "%";
        document.getElementById("latest").innerText = JSON.stringify(latestCopy, null, 2);

        // 감정 빈도수 집계
        const topEmotion = latest.top_emotion;
        if (topEmotion) {
          emotionCount[topEmotion] = (emotionCount[topEmotion] || 0) + 1;
        }
        const rankList = Object.entries(emotionCount)
          .sort((a,b)=>b[1]-a[1])
          .map(([k,v]) => `<li>${k}: ${v}회</li>`).join("");
        document.getElementById("emotionRank").innerHTML = rankList || "<li>데이터 없음</li>";
      } catch (e) {
        console.error(e);
      }
    }

    async function onStart() {
      const name = document.getElementById("username").value.trim();
      if (!name) {
        alert("사용자 이름을 먼저 입력해주세요.");
        return;
      }
      userName = name;
      await startCameraIfNeeded();

      if (!captureTimer) {
        captureTimer = setInterval(sendFrame, 200); // ~5fps
      }
      if (!pollTimer) {
        pollTimer = setInterval(poll, 700);
      }
    }

    function onStop() {
    stopCameraCapture();
    userName = "";   // ← 전송 완전 중단 핵심!!
}

    async function onSnapshot() {
      if (!userName) {
        alert("사용자 이름을 먼저 입력하고 시작하세요.");
        return;
      }
      try {
        const res = await fetch("/api/snapshot", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ user: userName }),
        });
        const j = await res.json();
        if (j.ok) {
          alert("현재 기준 이미지가 서버에 저장되었습니다.");
        } else {
          alert("저장할 프레임이 아직 없습니다.");
        }
      } catch (e) {
        alert("이미지 저장 중 오류: " + e);
      }
    }

    // 페이지 로드시 폴링만 준비 (실제 스트리밍은 onStart에서 시작)
    window.addEventListener("load", () => {
      pollTimer = setInterval(poll, 700);
    });
  </script>
</body>
</html>
